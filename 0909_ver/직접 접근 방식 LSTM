# 직접 접근 방식 LSTM

import pyupbit
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# 1. 데이터 수집
ticker = "KRW-ETH"
df = pyupbit.get_ohlcv(ticker, interval="day", count=800)
if df is None:
    print(f"{ticker} 데이터를 불러오는 데 실패했습니다.")
else:
    # 종가 데이터만 사용
    data = df['close'].values.reshape(-1, 1)

    # 2. 데이터 전처리
    # 데이터 정규화 (0과 1 사이로 스케일링)
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(data)

    # 시계열 데이터셋 생성
    def create_sequences(data, look_back, forecast_horizon):
        X, y = [], []
        for i in range(len(data) - look_back - forecast_horizon + 1):
            X.append(data[i:(i + look_back), 0])
            y.append(data[(i + look_back):(i + look_back + forecast_horizon), 0])
        return np.array(X), np.array(y)

    # 과거 60일 데이터로 미래 5일 예측
    look_back = 60
    forecast_horizon = 5
    X, y = create_sequences(scaled_data, look_back, forecast_horizon)

    # 훈련 데이터와 테스트 데이터 분리 (시간 순서 유지)
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    # LSTM 입력 형식으로 변환: [samples, time_steps, features]
    X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
    X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

    # 3. LSTM 모델 구축
    model = Sequential()
    model.add(LSTM(units=50, return_sequences=True, input_shape=(look_back, 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=50, return_sequences=False))
    model.add(Dropout(0.2))
    model.add(Dense(units=25))
    model.add(Dense(units=forecast_horizon)) # 출력층: 5일 예측

    # 모델 컴파일
    model.compile(optimizer='adam', loss='mean_squared_error')

    # 4. 모델 훈련
    print("모델 훈련을 시작합니다...")
    history = model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test), verbose=1)
    print("모델 훈련이 완료되었습니다.")

    # 5. 미래 5일 예측
    # 예측을 위해 가장 마지막 60일 데이터를 가져옴
    last_60_days = scaled_data[-look_back:]
    last_60_days = np.reshape(last_60_days, (1, look_back, 1))

    # 미래 5일 예측
    future_pred = model.predict(last_60_days)

    # 예측값을 원래 스케일로 되돌림
    future_pred_inv = scaler.inverse_transform(future_pred)

    print("\n--- 5일 후 이더리움(ETH/KRW) 가격 예측 ---")
    for i in range(forecast_horizon):
        print(f"{i+1}일 후 예측 가격: {future_pred_inv[0, i]:,.2f} KRW")

    # 6. 결과 시각화
    plt.style.use('seaborn-v0_8-darkgrid')
    plt.figure(figsize=(16, 8))
    
    # 과거 데이터 플롯 (최근 100일)
    last_100_days_actual = scaler.inverse_transform(scaled_data[-100:])
    plt.plot(np.arange(100), last_100_days_actual, label='Actual Price (Last 100 days)', color='blue')

    # 미래 예측 데이터 플롯
    future_dates = np.arange(100, 100 + forecast_horizon)
    plt.plot(future_dates, future_pred_inv[0], label='Predicted Price (Next 5 days)', color='red', marker='o')

    plt.title('ETH/KRW Price Prediction using LSTM', fontsize=20)
    plt.xlabel('Days', fontsize=15)
    plt.ylabel('Price (KRW)', fontsize=15)
    plt.legend()
    plt.show()
