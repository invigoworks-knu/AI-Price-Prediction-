# 위의 두 가지 방식 합친 VERSION

import pyupbit
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# ====================================
# 1. 설정 (Hyperparameters)
# ====================================
TICKER = "KRW-ETH"
DATA_COUNT = 800
LOOK_BACK = 60  # 과거 몇일의 데이터를 볼 것인가
FORECAST_HORIZON = 5  # 미래 몇일을 예측할 것인가
TRAIN_RATIO = 0.8
EPOCHS = 50
BATCH_SIZE = 32

# ====================================
# 2. 데이터 수집 및 전처리
# ====================================
print(f"{TICKER} 데이터 수집 중...")
df = pyupbit.get_ohlcv(TICKER, interval="day", count=DATA_COUNT)
data = df['close'].values.reshape(-1, 1)

# 데이터 정규화
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

# 시계열 데이터셋 생성 함수
def create_sequences(data, look_back, forecast_horizon):
    X, y = [], []
    for i in range(len(data) - look_back - forecast_horizon + 1):
        X.append(data[i:(i + look_back), 0])
        y.append(data[(i + look_back):(i + look_back + forecast_horizon), 0])
    return np.array(X), np.array(y)

X, y = create_sequences(scaled_data, LOOK_BACK, FORECAST_HORIZON)

# 데이터 분할
train_size = int(len(X) * TRAIN_RATIO)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# LSTM 입력 형식으로 변환
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

# ====================================
# 3. LSTM 모델 구축 및 훈련
# ====================================
model = Sequential([
    LSTM(units=50, return_sequences=True, input_shape=(LOOK_BACK, 1)),
    Dropout(0.2),
    LSTM(units=50, return_sequences=False),
    Dropout(0.2),
    Dense(units=25),
    Dense(units=FORECAST_HORIZON)
])

model.compile(optimizer='adam', loss='mean_squared_error')

print("모델 훈련 시작...")
model.fit(X_train, y_train, epochs=EPOCHS, batch_size=BATCH_SIZE, validation_data=(X_test, y_test), verbose=1)
print("모델 훈련 완료.")

# ====================================
# 4. 예측 및 결과 분석
# ====================================
# 테스트 데이터에 대한 예측 (모델 성능 평가용)
test_pred = model.predict(X_test)
test_pred_inv = scaler.inverse_transform(test_pred)
y_test_inv = scaler.inverse_transform(y_test)

# 미래 5일 예측
last_sequence = scaled_data[-LOOK_BACK:]
last_sequence = np.reshape(last_sequence, (1, LOOK_BACK, 1))
future_pred = model.predict(last_sequence)
future_pred_inv = scaler.inverse_transform(future_pred).flatten()

print("\n--- 향후 5일 이더리움(ETH/KRW) 가격 예측 ---")
for i in range(FORECAST_HORIZON):
    print(f"{i+1}일 후 예측 가격: {future_pred_inv[i]:,.2f} KRW")

# 일별 상승/하락폭 계산
diffs = np.diff(future_pred_inv)
print("\n--- 예측된 일별 상승/하락폭 ---")
for i, diff in enumerate(diffs):
    print(f"{i+1}일차 -> {i+2}일차 변동폭: {diff:,.2f} KRW")

# ====================================
# 5. 결과 시각화
# ====================================
plt.style.use('seaborn-v0_8-darkgrid')
plt.figure(figsize=(16, 8))

# 1. 테스트 데이터 구간의 실제 가격 (날짜 인덱싱 수정)
start_index = train_size + LOOK_BACK
end_index = start_index + len(y_test)
test_dates = df.index[start_index:end_index]
plt.plot(test_dates, y_test_inv[:, 0], label='Actual Price (Test)', color='blue')

# 2. 테스트 데이터 구간의 예측 가격
plt.plot(test_dates, test_pred_inv[:, 0], label='Predicted Price (Test)', color='orange', linestyle='--')

# 3. 미래 5일 예측 가격
future_dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=FORECAST_HORIZON)
plt.plot(future_dates, future_pred_inv, label=f'Future Forecast ({FORECAST_HORIZON} days)', color='red', marker='o')

plt.title('ETH/KRW Price Prediction (Direct Multi-output LSTM)', fontsize=20)
plt.xlabel('Date', fontsize=15)
plt.ylabel('Price (KRW)', fontsize=15)
plt.legend()
plt.grid(True)
plt.show()
